---
title: MySQL架构与存储引擎
publishDate: 2022-12-05
description: 'MySQL详解：MySQL架构设计与存储引擎讲解'
tags:
  - 数据库
  - MySQL
  
language: '中文'
---





# MySQL架构



![image.png](https://cdn.nlark.com/yuque/0/2022/png/12995622/1647247472723-3158329f-074a-4060-8cef-f1470b4951a2.png?x-oss-process=image%2Fformat%2Cwebp)



MySQL可以分为**Server层**和**存储引擎层**两部分 

+ Server层包括**连接器、查询缓存、分析器、优化器、执行器**等涵盖MySQL的大多数核心服务功能
  + 以及所有的内置函数（如日期、时间、数学和加密函数等）
  + 所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。
+ **存储引擎层负责数据的存储和提取**。
  + 其架构模式是插件式的，支持InnoDB、MyISAM、Memory等多个存储引擎。
  + **现在最常用的存储引擎是InnoDB**，它从MySQL5.5.5版本开始成为了**默认存储引擎**



##  Server层



### 连接器

1. 第一步， 你会先连接到这个数据库上， 这时候接待你的就是连接器。
   -  **连接器负责跟客户端建立连接、 获取权限、 维持和管理连接**。 
   - 连接命令一般是这么写的：  `mysql -h$ip -P$port -u$user -p`
2. 完成经典的TCP握手后， 连接器就要开始认证你的身份， 这个时候用的就是你输入的用户名和密码。 
   - **如果用户名或密码不对**， 你就会收到一个"Access denied for user"的错误， 然后客户端程序**结束执行。**
   - 如果用户名密码**认证通过，** 连接器会到权限表里面**查出你拥有的权限**。 之后， 这个连接里面的权限判断逻辑， 都将依赖于此时读到的权限。
   - 这就意味着，<font style="color:#E8323C;"> 一个用户成功建立连接后， 即使你用管理员账号对这个用户的权限做了修改， 也不会影响已经存在连接的权限</font>。 修改完成后， 只有再新建的连接才会使用新的权限设置。
   - 连接完成后， 如果你没有后续的动作， 这个连接就处于空闲状态， 你可以在show processlist命令中看到它。
3. 高并发场景下，连接数管理是性能瓶颈之一，常配合连接池（如 HikariCP、Druid）在应用层复用连接

+ **长连接与短连接 **
  - <font style="background-color:#FCFCCA;">长连接指连接成功后，如果客户端有请求，则一直使用同一个连接</font>
  - <font style="background-color:#FCFCCA;">短连接指执行很少的几次查询之后，就断开连接。</font>
  - 长连接mysql的，如果太久没有动静，mysql默认8h会自动断开，可以使用wait_timeout参数控制。
+ **全部使用长连接Mysql内存涨特别快的解决方案 **
  1. <font style="background-color:#FCFCCA;">定期断开长连接</font>。或者执行一个占用内存大的查询之后断开连接，之后再重连。
  2. 5.7以上版本可以<font style="background-color:#FCFCCA;">通过执行mysql_reset_connection来重新初始化连接资源</font>。 这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态





### 查询缓存


+ 连接建立完成之后，会到查询缓存中查询数据。
+ 查询缓存的存储默认key为查询语句，而value为结果。
+ **<font style="color:#E8323C;">查询缓存弊大于利，因为只要有表更新，这个表相关的缓存就会被清除。</font>**
+ query_cache_type 设置成DEMAND，可取消查询缓存。
+ 显示的查询缓存数据 `mysql> select SQL_CACHE * from T where ID=10；`
+ **mysql 8 版本直接移除了查询缓存。**



### 分析器


+ 主要做语法解析，并判断语法是否合规。





### 优化器

<font style="color:#E8323C;">在开始执行之前， 还要先经过优化器的处理。</font>

+ **优化器是在表里面有多个索引的时候，决定使用哪个索引**；
+ 或者在一个语句有多表关联（join）的时候， **决定各个表的连接顺序**。
+ 比如你执行下面这样的语句，这个语句是执行两个表的join：  
  `mysql> select * from t1 join t2 using(ID) where t1.c=10 and t2.d=20;`
  + 既可以先从表t1里面取出c=10的记录的ID值，再根据ID值关联到表t2，再判断t2里面d的值是否等于20。
  + 也可以先从表t2里面取出d=20的记录的ID值，再根据ID值关联到t1，再判断t1里面c的值是否等于10。  
  + 这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，**而优化器的作用就是决定选择效率高的方案。**



### 执行器

- 根据优化器生成的执行计划，调用“存储引擎”的接口来执行 SQL。
- 负责权限校验（如 SELECT 权限、UPDATE 权限等）。
- 处理事务、触发器、外键约束等逻辑。
- 返回结果集给客户端。




```plain
mysql> select * from T where ID=10;
```

+  首先判断语句是否与查询权限，若无则直接返回 
+  比如我们这个例子中的表T中，ID字段**没有索引，那么执行器的执行流程是这样的：**  
   1.调用InnoDB引擎接口取这个表的第一行，判断ID值是不是10，如果不是则跳过，如果是则将这行存在结果集中；  
   2.调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。  
   3.执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。 



**对于有索引的表，执行的逻辑也差不多。**

1. 第一次调用的是“取满足条件的第一行”这个接口，之后循环取“满足条件的下一行”这个接口，这些接口都是引擎中已经定义好的。
2. 你会在数据库的慢查询日志中看到一个rows_examined的字段，表示这个语句执行过程中扫描了多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的。

<font style="color:#E8323C;">在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此引擎扫描行数跟rows_examined并不是完全相同的。</font>





## 存储引擎

**存储引擎（Storage Engines）** 是 MySQL 中负责数据的“物理存储、检索、索引管理、事务控制、并发控制、崩溃恢复”等底层操作的模块。

- 服务层（SQL Parser/Optimizer/Executor）是“统一接口”，不关心数据怎么存。
- 存储引擎是“具体实现”，不同引擎有不同存储结构和行为。
- MySQL 通过“handler API”与存储引擎交互，实现解耦。

> 简单比喻：MySQL 服务层是“操作系统”，存储引擎是“文件系统”（如 NTFS、ext4、FAT32），你可以为不同分区选择不同文件系统。 



MySQL 支持多种存储引擎，其中 **MyISAM** 和 **InnoDB** 是最主流的两种。

- **MyISAM**：MySQL 5.5 之前默认的存储引擎，以高性能读取著称，但不支持事务。
- **InnoDB**：MySQL 5.5 及以后版本的默认存储引擎，支持 ACID 事务、行级锁和外键约束，适用于高并发写入场景。

一般来说，我们平时工作、面试中，用到的都是InnoDB，所以我会着重讲解一下InnoDB的内容。

--------



### MyISAM

#### 核心机制

- **表结构存储**：
  - `.frm` 文件：存储表定义（字段、类型等）。
  - `.MYD`（MYData）文件：存储实际数据。
  - `.MYI`（MYIndex）文件：存储索引信息。
- **锁机制**：仅支持**表级锁（Table-level Locking）**。
  - 任何写操作（INSERT/UPDATE/DELETE）都会锁定整张表，读操作可并发进行（但写操作会阻塞所有读写）。
- **索引结构**：使用 **B+Tree** 索引，但**不支持聚簇索引（Clustered Index）**。
  - 数据文件和索引文件是分离的。
- **事务支持**：**不支持事务（Non-Transactional）**
  - 无法回滚，不具备 ACID 特性。
- **崩溃恢复**：无自动崩溃恢复能力。
  - 表损坏后需手动修复（如使用 `REPAIR TABLE`）。

#### 主要特性

| 特性         | 说明                                         |
| ------------ | -------------------------------------------- |
| **读性能**   | **极高，尤其适用于只读或读多写少场景！！！** |
| 全文索引     | 支持（MySQL 5.6 之前 InnoDB 不支持）         |
| 压缩表       | 支持（`myisampack` 工具）                    |
| 空间数据类型 | 支持（GIS）                                  |
| 行数统计     | `SELECT COUNT(*)` 非常快（直接读取元数据）   |

#### 优缺点总结

**优点**：

- 结构简单，开销小。
- 读取速度快，尤其适合大量 SELECT 操作。
- 支持全文索引（早期版本优势）。
- 表可压缩，节省磁盘空间。

**缺点**：

- **不支持事务，数据一致性无法保障。**
- **表级锁导致高并发写入性能差。**
- 崩溃后易损坏，恢复困难。
- 不支持外键约束。



-----



### InnoDB

#### 核心机制

- **表结构存储**：
  - `.frm` 文件（MySQL 8.0 后元数据存于数据字典中）。
  - 数据和索引统一存储在 **表空间（Tablespace）** 中（默认为共享表空间 `ibdata1`，也可配置为每个表独立文件 `.ibd`）。
- **锁机制**：支持**行级锁（Row-level Locking）** 和 **表级锁**。行锁极大提升了并发写入性能。
- **索引结构**：使用 **聚簇索引（Clustered Index）**。
  - 主键索引的叶子节点直接存储行数据，非主键索引（二级索引）的叶子节点存储主键值。
- **事务支持**：完全支持 **ACID 事务**，提供 `COMMIT`、`ROLLBACK` 和崩溃恢复能力。
- **崩溃恢复**：基于 **Redo Log（重做日志）** 和 **Undo Log（回滚日志）** 实现崩溃安全（Crash-safe）。
- **MVCC（多版本并发控制）**：通过 Undo Log 实现非锁定读（快照读），提升并发性能。



#### 主要特性

| 特性         | 说明                             |
| ------------ | -------------------------------- |
| 事务支持     | 完整 ACID 支持                   |
| 外键约束     | 支持（Referential Integrity）    |
| 行级锁       | 高并发写入性能优异               |
| MVCC         | 支持一致性非锁定读               |
| 崩溃恢复     | 自动恢复，数据安全               |
| 全文索引     | MySQL 5.6+ 支持                  |
| 自增长锁优化 | MySQL 8.0 引入更高效的自增锁机制 |



#### 优缺点总结

**优点**：

- 支持事务，保障数据一致性。
- 行级锁 + MVCC，高并发性能好。
- 崩溃恢复能力强，数据安全。
- 支持外键，维护数据完整性。
- 现代应用的标准选择。

**缺点**：

- 相比 MyISAM，读取性能略低（尤其无 WHERE 条件的全表扫描）。
- 占用更多磁盘空间（因事务日志、回滚段等）。
- `SELECT COUNT(*)` 较慢（需全表扫描，除非有覆盖索引）。



### 两者对比

| 对比维度            | MyISAM                    | InnoDB                             |
| ------------------- | ------------------------- | ---------------------------------- |
| **事务支持**        | ❌ 不支持                  | ✅ 支持                             |
| **锁粒度**          | 表级锁                    | 行级锁（默认）                     |
| **外键约束**        | ❌ 不支持                  | ✅ 支持                             |
| **崩溃恢复**        | ❌ 需手动修复              | ✅ 自动恢复                         |
| **全文索引**        | ✅ 支持（所有版本）        | ✅ 5.6+ 支持                        |
| **聚簇索引**        | ❌ 非聚簇                  | ✅ 聚簇（主键）                     |
| **MVCC**            | ❌ 不支持                  | ✅ 支持                             |
| **存储结构**        | .frm + .MYD + .MYI        | .frm（或数据字典）+ 表空间（.ibd） |
| **`COUNT(*)` 性能** | ⚡ 极快（元数据）          | 🐢 较慢（需扫描）                   |
| **适用场景**        | 只读/读多写少、日志、报表 | OLTP、高并发、事务型应用           |

#### 

#### 选择MyISAM场景

- 应用以**只读或读为主**（如数据仓库、日志系统、报表系统）。
- 不需要事务和外键。
- 对 `COUNT(*)` 性能要求极高。
- 磁盘空间敏感，可接受表压缩。

>  注意：随着 InnoDB 在 MySQL 5.6+ 中支持全文索引，MyISAM 的优势场景已大幅缩小。



#### 选择InnoDB场景

- 需要**事务支持**（如电商、金融、订单系统）。
- **高并发写入**场景（如用户注册、消息系统）。
- 要求**数据完整性**（外键约束）。
- 应用对**数据安全性和崩溃恢复**有要求。
- 现代 Web 应用（LAMP/LEMP 架构）。

> **官方建议**：除非有明确理由使用 MyISAM，否则一律使用 InnoDB。



所以，综上所述，我们发现，大多数情况下还是要用innodb，只有在某些读操作密集的时候，可以使用MyISAM，但是代价是你无法使用事务、崩溃恢复等特性，这显然是得不偿失的。

-----



## SQL执行详解

#### SELECT SQL

```sql
select * from SYS_USER;
```



1. 客户端发起请求，进入连接器，连接器就是管理链接，权限验证，看看你的这个账号密码对不对，如果通过，进入下一步
2. 此时有两个分叉 
   1. **先会查询缓存，缓存如果有结果，直接返回结果，如果没有，进行分析器步骤**
   2. 走分析器，进行词法分析，语法分析，比如select from where 这几类关键字，然后到优化器，看看能不能进行优化性能之类，比如索引下推等，最后到执行器，开始执行，返回结果
   3. **注意：**查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。因此很可能你费劲地把结果存起来，还没使用呢，就被一个更新全清空了。对于更新压力大的数据库来说，查询缓存的命中率会非常低。除非你的业务就是有一张静态表，很长时间才会更新一次。比如，一个系统配置表，那这张表上的查询才适合使用查询缓存。
3. 默认是用的innodb引擎



#### UPDATE SQL



```sql
update `article` set `commentcnt` = `commentcnt` + 1 where `id` = 2;
```

1. **连接器会先检查权限**，若没有权限就直接返回错误信息
   1. 如果有权限就会**清除查询缓存**（MySQL 8.0版本之前）
   2. **将article表所有缓存结果都清空**（一般不建议使用查询缓存）。接下来执行下一步。
2. 通过分析器先进行**词法分析**，**提取sql语句里面的关键字**。
   1. 示例SQL取的update，然后提取要更新的表名article ，更新条件是id= 2 
   2. 然后进行语法分析，**判断sql语句是否正确**，如果有错会返回报错信息，否则执行下一步。
3. 优化器**确定执行方案**。
   1. 优化器根据自己的优化算法选择一个执行效率最好的一个方案。
   2. 比如：优化器会去找id字段有没有索引，使用id主键索引，执行计划确定后就会执行下一步。
4. 执行器首先会判断当前用户对article表是否有更新的权限
   1. 如果没有权限就会返回权限错误
   2. 若有权限会打开表执行，根据表的引擎定义调用引擎提供的接口，返回引擎执行结果。

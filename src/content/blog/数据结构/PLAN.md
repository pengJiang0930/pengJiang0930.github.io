---
title: 人工智能系统实践
publishDate: 2024-06-15 07:32:27
description: '北京大学 2024 年春季学期人工智能基础 - 笔记 17'
tags:
  - 数据结构
  
language: '中文'
---


## 一、数组（Array）

### 📌 核心知识点
- 内存连续分配特性与随机访问原理
- 静态数组 vs 动态数组（自动扩容机制）
- 时间复杂度分析：访问 O(1)，插入/删除 O(n)
- 缓存局部性原理（CPU Cache Friendly）
- 扩容策略（通常为2倍扩容）与缩容触发条件（如 size < capacity/4）

### ⚠️ 学习难点
- 扩容时的数据搬移与性能损耗
- 边界条件处理（index < 0 或 ≥ size）
- 缩容时的“抖动问题”（频繁扩容缩容）

### ✅ 吃透标准
- 能独立手写一个泛型动态数组类（如 `DynamicArray<T>`），支持：
  - `add(T element)`（尾部添加，自动扩容）
  - `remove(int index)`（删除指定位置，数据前移）
  - `get(int index)` / `set(int index, T element)`
  - `size()` / `capacity()`
- 能在白板/纸上无BUG写出扩容逻辑
- 能口述“为什么数组访问快”、“扩容为什么是2倍”

### 🧩 面试价值：★★★☆☆  
> 基础中的基础，常作为其他结构（如堆、哈希表）的底层容器，面试常考“动态扩容实现”

---

## 二、链表（Linked List）

### 📌 核心知识点
- 节点结构（数据域 + 指针域）
- 单向链表 vs 双向链表 vs 循环链表
- 头插法、尾插法、指定位置插入
- 虚拟头节点（Dummy Node）技巧
- 快慢指针应用（找中点、判环、删除倒数第N节点）
- 时间复杂度：访问 O(n)，插入/删除 O(1)（已知节点时）

### ⚠️ 学习难点
- 指针操作易出错（尤其删除节点时）
- 边界情况（空链表、单节点、删除头节点）
- 递归与迭代实现反转链表的思维转换

### ✅ 吃透标准
- 能手写单链表类（含 `Node` 内部类），支持：
  - `addAtHead(val)`, `addAtTail(val)`, `addAtIndex(index, val)`
  - `deleteAtIndex(index)`
  - `reverse()`（迭代与递归两种实现）
  - `hasCycle()`（快慢指针判环）
- 能画图说明“虚拟头节点如何简化边界处理”
- 能对比“数组 vs 链表”的适用场景

### 🧩 面试价值：★★★★★  
> 高频面试题来源（反转、合并、环检测），是理解“指针操作”和“递归思维”的基石

---

## 三、栈（Stack）

### 📌 核心知识点
- LIFO（后进先出）特性
- 数组实现 vs 链表实现
- 核心操作：push / pop / peek / isEmpty
- 应用场景：括号匹配、函数调用栈、表达式求值、浏览器后退
- 单调栈概念（为后续算法题铺垫）

### ⚠️ 学习难点
- 用栈模拟递归行为
- 多栈协作问题（如“用两个栈实现队列”）
- 栈溢出边界处理

### ✅ 吃透标准
- 能手写 `MyStack<T>` 类（基于数组或链表），支持标准操作
- 能用两个栈实现一个队列（`MyQueue<T>`），并分析时间复杂度
- 能手写“括号匹配”算法（`isValid(String s)`）
- 能口述“函数调用栈”工作原理

### 🧩 面试价值：★★★☆☆  
> 常结合“表达式解析”“DFS模拟”出题，是理解“递归转迭代”的关键结构

---

## 四、队列（Queue）

### 📌 核心知识点
- FIFO（先进先出）特性
- 普通队列 vs 循环队列（解决假溢出）
- 双端队列（Deque）概念
- 阻塞队列与生产者-消费者模型（了解）
- 滑动窗口问题中的队列应用

### ⚠️ 学习难点
- 循环队列的“模运算”边界控制（front / rear 指针）
- “假溢出”与“真溢出”的区别
- 双端队列的灵活应用（如“最大值队列”）

### ✅ 吃透标准
- 能手写循环队列 `CircularQueue`，支持：
  - `enqueue(val)`, `dequeue()`
  - `isEmpty()`, `isFull()`
  - 正确处理 front/rear 指针循环
- 能用队列实现层序遍历二叉树
- 能口述“为什么循环队列比普通队列高效”

### 🧩 面试价值：★★★☆☆  
> BFS、滑动窗口、任务调度等场景高频使用，循环队列是重点考察实现

---

## 五、哈希表（Hash Table）

### 📌 核心知识点
- 哈希函数设计（取模、扰动）
- 冲突解决：拉链法（链表） vs 开放寻址（线性探测、二次探测）
- 负载因子（Load Factor）与扩容（Rehash）机制
- 时间复杂度：平均 O(1)，最坏 O(n)
- Java HashMap 底层结构（数组 + 链表 + 红黑树）

### ⚠️ 学习难点
- 哈希冲突的处理策略选择
- Rehash 时的数据重新分布
- 线程安全问题（非本阶段重点）
- 哈希函数的“均匀分布”设计

### ✅ 吃透标准
- 能手写简易 `MyHashMap<K, V>`（基于拉链法），支持：
  - `put(K key, V value)`
  - `get(Object key)`
  - `remove(Object key)`
  - 负载因子 > 0.75 触发扩容（容量翻倍 + 重新哈希）
- 能画图说明“拉链法如何解决冲突”
- 能口述“为什么HashMap初始容量是2的幂”
- 能对比“拉链法 vs 开放寻址”优劣

### 🧩 面试价值：★★★★★  
> 几乎必考！从实现到应用（缓存、去重、计数）全覆盖，是工程能力核心体现

---

## 六、树（Tree）— 以二叉树为核心

### 📌 核心知识点
- 树的基本术语：根、叶、深度、高度、度
- 二叉树：满二叉树、完全二叉树、二叉搜索树（BST）
- 遍历方式：前序、中序、后序（递归 + 迭代）、层序（BFS）
- BST 性质与验证方法
- 平衡树概念（AVL、红黑树 — 了解思想即可）

### ⚠️ 学习难点
- 迭代遍历的栈模拟（尤其后序遍历）
- 递归边界条件（root == null）
- BST 验证中的“区间约束”思维
- 树的序列化与反序列化

### ✅ 吃透标准
- 能手写 `TreeNode` 类
- 能用递归和迭代两种方式实现：
  - `preorderTraversal()`
  - `inorderTraversal()`
  - `postorderTraversal()`
  - `levelOrder()`
- 能实现 `isValidBST(TreeNode root)`（用递归+区间约束）
- 能口述“BST中序遍历是递增序列”的原理

### 🧩 面试价值：★★★★★  
> 树是递归思维的终极训练场，90%大厂必考遍历与BST，是系统设计基础

---

## 七、堆（Heap）— 优先队列实现基础

### 📌 核心知识点
- 完全二叉树的数组表示法
- 大顶堆 vs 小顶堆
- 堆的核心操作：插入（上浮）、删除堆顶（下沉）
- 堆排序思想（非重点）
- PriorityQueue 底层实现

### ⚠️ 学习难点
- 上浮（swim）与下沉（sink）的边界控制
- 建堆的两种方式（自顶向下 vs 自底向上）
- Top-K 问题的堆解法

### ✅ 吃透标准
- 能手写 `MinHeap<T extends Comparable<T>>`，支持：
  - `insert(T val)`
  - `extractMin()`
  - `peek()`
  - `isEmpty()`
- 能用堆解决“前K个最大/最小元素”问题
- 能口述“为什么堆用数组而不用链表”
- 能对比“堆排序 vs 快速排序”适用场景

### 🧩 面试价值：★★★★☆  
> Top-K、数据流中位数、任务调度等高频场景，是“空间换时间”的经典结构

---

## 八、图（Graph）— 侧重基础概念与遍历

### 📌 核心知识点
- 图的表示：邻接矩阵 vs 邻接表
- 有向图 vs 无向图
- 图的遍历：BFS（广度优先） vs DFS（深度优先）
- 拓扑排序（有向无环图DAG）
- 最短路径概念（Dijkstra、Floyd — 了解思想即可）

### ⚠️ 学习难点
- 邻接表的构建与遍历
- BFS/DFS 的递归与队列/栈实现
- 拓扑排序的“入度”统计与队列维护
- 环检测（DFS染色法）

### ✅ 吃透标准
- 能手写 `Graph` 类（基于邻接表），支持：
  - `addEdge(int u, int v)`
  - `bfs(int start)`
  - `dfs(int start)`
- 能实现拓扑排序（如课程表问题）
- 能口述“BFS为什么能求最短路径（无权图）”
- 能画图说明“邻接表 vs 邻接矩阵”的空间复杂度差异

### 🧩 面试价值：★★★☆☆  
> 社招考察较少，但外企/算法岗可能涉及，重点掌握BFS/DFS和拓扑排序

---

## 📊 附：掌握程度自测表

| 结构   | 能否手写无BUG实现？ | 能否讲清原理？ | 能否分析复杂度？ | 能否说出应用场景？ | 综合评分 |
| ------ | ------------------- | -------------- | ---------------- | ------------------ | -------- |
| 数组   | ✅                   | ✅              | ✅                | ✅                  | ★★★★☆    |
| 链表   | ✅                   | ✅              | ✅                | ✅                  | ★★★★★    |
| 栈     | ✅                   | ✅              | ✅                | ✅                  | ★★★★☆    |
| 队列   | ✅                   | ✅              | ✅                | ✅                  | ★★★★☆    |
| 哈希表 | ✅                   | ✅              | ✅                | ✅                  | ★★★★★    |
| 树     | ✅                   | ✅              | ✅                | ✅                  | ★★★★★    |
| 堆     | ✅                   | ✅              | ✅                | ✅                  | ★★★★☆    |
| 图     | ✅                   | ✅              | ✅                | ✅                  | ★★★☆☆    |

> ✅ 达到“4项全勾”才算“吃透”，否则回炉重学

---

## 📜 学习原则与建议

1. **拒绝“看懂即会”** —— 每个结构必须手写实现，不调用语言内置类库  
2. **重视“白板能力”** —— 能在无IDE环境下写出无语法错误的代码  
3. **输出倒逼输入** —— 每学完一个结构，写一篇技术博客或画一张原理图  
4. **复杂度是灵魂** —— 任何操作必须能说出时间/空间复杂度  
5. **面试导向学习** —— 重点攻克链表、哈希表、树、堆，图可适当降低优先级
